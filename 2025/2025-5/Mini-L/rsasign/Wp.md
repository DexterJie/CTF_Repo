可以把一些已知量当作`t`，即`t = a + b + a*b`，那么`gift`可以写成下式


$$
gift \equiv (p+q+t)^2 \mod phi
$$

$$
\therefore gift = (p+q+t)^2 - kphi
$$



自己生成数据测一下会发现这个k大概率等于4，把`p + q`记为`x`，那么就有


$$
gift = (x+t)^2 - k(n-x+1)
$$


在`RealField`下求解可以得到x的高284位，得到x的高位再解方程组分别得到p,q的高位，最后打高位泄露

```python
from Crypto.Util.number import *

e,n = (65537,103894244981844985537754880154957043605938484102562158690722531081787219519424572416881754672377601851964416424759136080204870893054485062449999897173374210892603308440838199225926262799093152616430249061743215665167990978654674200171059005559869946978592535720766431524243942662028069102576083861914106412399)
c = 50810871938251627005285090837280618434273429940089654925377752488011128518767341675465435906094867261596016363149398900195250354993172711611856393548098646094748785774924511077105061611095328649875874203921275281780733446616807977350320544877201182003521199057295967111877565671671198186635360508565083698058
gift = 2391232579794490071131297275577300947901582900418236846514147804369797358429972790212
gift = gift << 740
k = 4
a = bytes_to_long(b'miniL')
b = bytes_to_long(b'mini7')
t = a + b + a*b
R.<x> = PolynomialRing(RealField(1024))
f = (x+t)^2 - k*(n-x+1) - gift
res = f.roots()
paddq_h = int(res[1][0])

var('p q')
f1 = p*q == n
f2 = p+q == paddq_h
res = solve([f1,f2],[p,q])
p,q = int(res[0][0].rhs()),int(res[0][1].rhs())
bit = 236
ph = p >> bit << bit
print(f"ph = {ph}")

R.<x> = PolynomialRing(Zmod(n))
f = ph + x
res = f.monic().small_roots(X=2^236,beta=0.49,epsilon=0.02)
print(res)
if res != []:
    p = int(ph + res[0])
    q = n // p
    d = inverse(e,(p-1)*(q-1))
    m = pow(c,d,n)
    print(long_to_bytes(m))
    # miniL{D0_Y@U_Li)e_T&@_RRRSA??}
```



