
$$
gift = 2025p^2+r^2p \mod \phi(n)
$$

可以写为
$$
gift = 2025p^2 + r^2p - k\times \phi(n)
$$

$$
gift = 2025p^2 + r^2p - k(n +1 - p - \frac{n}{p})
$$

再同乘p
$$
gift \times p = 2025p^3 + r^2p^2 - k(np + p - p^2 - n)
$$

$$
f(p) = 2025p^3 + r^2p^2 - knp -kp +kp^2+kn - gift\times p
$$

$$
f(p) = 2025p^3 + (r^2 + k)p^2 - (kn+k+gift)p + kn
$$

这里的k就10多bit，在可爆破范围内，解这个方程可以得到p的高位。

实际测试保守能得到p的高280位，然后一元copper恢复p就好了

> exp

```py
from Crypto.Util.number import *
from tqdm import trange

n = 127060392619341060272126983366487069092712215979664340339428955285201267724168574813227106020122399594060458777939446978632526348867806863618885370221957087197582864380885199290793062293120324984868138488667017882272415668310242448870352699380394381756621677031459335310964085476227148301120850021800822495119
e = 65537
ct = 18305235107479382231970252522433686185039231184629854177334609960907102735540326234277108553640185845164498239822263821349544015918443334769445559622730315115384134147808359107914969010678607157349844717217781801237935737980608575612421610972048739840839726108493286994232100086338529591086935374295281642738
gift = 8312456126096895497368692810699639462746223116345115761188530231045483000989605820
gift = gift << 750

r = bytes_to_long(b'n1junior2025')

for k in trange(2048,4096):
    R.<p> = PolynomialRing(RealField(1024))
    f = 2025*p^3 + (r^2+k)*p^2 - (k*n+k+gift)*p + k*n
    res = f.roots()
    unknwon = 512 - 280
    phigh = int(abs(res[0][0])) >> unknwon << unknwon
    R.<x> = PolynomialRing(Zmod(n))
    g = phigh + x
    res1 = g.small_roots(X=2^unknwon,beta=0.49,epsilon=0.04)
    if res1 != []:
        print(k)
        print(res1)
        p = phigh + int(res1[0])
        if n % p == 0:
            q = n // p
            d = inverse(e,(p-1)*(q-1))
            m = pow(ct,d,n)
            print(long_to_bytes(int(m)))
            break
            # flag{ec6f23afd0b7453bb8224146b6aad196}
```

k = 2347