# part1

通过已知的flag头提取出5个对应LCG部分的值再恢复seed，得到seed之后往下推，如果符合$seed_{n+1} = a\times seed_n + b \mod p$的就是0，否则就是1

# part2

由题意得
$$
c \equiv m_0\times(0+4660)^e + m_1 \times (1+4660)^e +... + m_k\times(k+4660)^e \mod n
$$
此时的m的取值范围应该是$(65,128)$，为了降低目标向量，可以写为下式
$$
c \equiv (x_0 + 64)\times (0+4660)^e + (x_1 + 64)\times (1+4660)^e +...+(x_k + 64) \times (k+4660)^e \mod n
$$
造格
$$
\begin{pmatrix}
x_0 & x_1 & ... & x_k &1 &k
\end{pmatrix}
\begin{pmatrix}
1 & 0 & ... & 0 & 0 & (0+4660)^e\\
0 & 1 & ... & 0 & 0 & (1+4660)^e\\
\vdots & \vdots & \ddots & \vdots & \vdots & \vdots\\
0 & 0 & ... & 1 & 0 & (k+4660)^e\\
0 & 0 & ... & 0 & 1 & 64\sum_{i=0}^{k}(i+4660)^e - c\\
0 & 0 & ... & 0 & 0 & n
\end{pmatrix}
=
\begin{pmatrix}
x_0 & x_1 & ... & x_k &1 &0
\end{pmatrix}
$$

> exp

```py
from Crypto.Util.number import *

n = []
R.<a,b> = PolynomialRing(ZZ)

def next(x):
    return a*x + b

f1 = next(next(n[0])) - n[2]
f2 = next(next(n[2])) - n[4]
f3 = next(next(next(n[4]))) - n[7]
f4 = next(n[7]) - n[8]
f5 = next(next(n[8])) - n[10]

F = [f1,f2,f3,f4,f5]
I = Ideal(F).groebner_basis()

p = ZZ(I[2])
a = Zmod(p)(-I[0].univariate_polynomial()(0))
b = Zmod(p)(-I[1].univariate_polynomial()(0))

seed = n[0]
m1 = '0'
for value in n[1:]:
    seed = (a*seed + b) % p
    if seed == value:
        m1 += '0'
    else:
        m1 += '1'

flag1 = long_to_bytes(int(m1,2))
print(flag1)
n = 16880924655573626811763865075201881594085658222047473444427295924181371341406971359787070757333746323665180258925280624345937931067302673406166527557074157053768756954809954623549764696024889104571712837947570927160960150469942624060518463231436452655059364616329589584232929658472512262657486196000339385053006838678892053410082983193195313760143294107276239320478952773774926076976118332506709002823833966693933772855520415233420873109157410013754228009873467565264170667190055496092630482018483458436328026371767734605083997033690559928072813698606007542923203397847175503893541662307450142747604801158547519780249
e = 65537
c = 9032357989989555941675564821401950498589029986516332099523507342092837051434738218296315677579902547951839735936211470189183670081413398549328213424711630953101945318953216233002076158699383482500577204410862449005374635380205765227970071715701130376936200309849157913293371540209836180873164955112090522763296400826270168187684580268049900241471974781359543289845547305509778118625872361241263888981982239852260791787315392967289385225742091913059414916109642527756161790351439311378131805693115561811434117214628348326091634314754373956682740966173046220578724814192276046560931649844628370528719818294616692090359

for k in range(32,40):
    flag2 = ''
    length = k + 2
    Ge = Matrix(ZZ,length,length)
    t = -c
    for i in range(k):
        cc = pow((i + 4660),e,n)
        Ge[i,i] = 1
        Ge[i,-1] = cc
        t += 64*cc
        t %= n
    
    Ge[-2,-2] = 1
    Ge[-2,-1] = t
    Ge[-1,-1] = n
    
    Ge[:,-1] *= 2^2050
    for line in Ge.LLL():
        if line[-1] == 0 and all(x < 128 for x in line[:-2]):
            print(line)
            for m in line[:-2]:
                if m < 0:
                    flag2 += chr(64 + abs(m))
                else:
                    flag2 += chr(64 + m)

    print(flag2)
```

得到`VNCTF{Happy_New_Year_C0ngratu1atiPns_On_RecPvering_The_Messages}`

猜了半天flag：`VNCTF{Happy_New_Year_C0ngratu1ati0ns_On_Rec0vering_The_Messages}`

